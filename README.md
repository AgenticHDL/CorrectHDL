# CorrectHDL: Agentic HDL Design with LLMs Leveraging HLS as Reference

## Overview

CorrectHDL is an agentic LLM-assisted HDL design framework that leverages HLS-generated HDL as a functional reference. Starting from a C/C++ program, complex algorithms are decomposed into LLM-friendly submodules whose HDL implementations are generated by the LLM. Syntax errors are corrected via Retrieval-Augmented Generation (RAG), and functional discrepancies are resolved through differential verification against the HLS-generated golden reference. By leveraging HLS-generated HDL as a functional reference, CorrectHDL implements an end-to-end design flow that covers HDL generation, runtime profiling, differential verification, iterative repair, and PPA evaluation, enabling efficient hardware design.

## Repository Structure

The repository contains:
  A set of scripts that implement C/C++ decomposition into submodules, submodule verification,top-level re-integration and verification.
  A set of Python scripts:
  1. Set up submodule interface descriptions.
  2. Generate specifications for each submodule.
  3. Prepare submodule simulation environments.
  4. Drive submodule HDL generation, syntax repair, and differential verification versus HLS-generated golden HDL.
  5. Finally perform top-level concatenation and verification.

## Requirements

### Software

- **Python:** 3.8+
- **Python packages:**
  - An LLM client (e.g., `openai` or a compatible HTTP client such as `requests`)
- **EDA tools:**
  - An HLS tool such as **Siemens EDA Catapult HLS** 
  - An RTL simulator such as **Siemens EDA ModelSim/QuestaSim** 
  - A Logic synthesis tool such as **Synopsys Design Compiler**

### Environment / Credentials

- Environment variable **`OPENAI_API_KEY`** must be set for LLM access.

### Helper Script

Both the C and HDL stages assume a project-specific helper:

- **`compileh.py`** — a script that compiles and simulates HLS or RTL designs in your environment (e.g., invoking Catapult/VCS/ModelSim).  
  This script must:
  - Be located where the pipelines expect it.
  - Be executable from the subdirectories created by the scripts.

## HDL Generation & Differential Verification

Once the C decomposition passes, **Part II** (implemented in `vsplit/`) converts each C/C++ submodule into Verilog, verifies it against HLS-generated reference HDL, and then integrates all modules into a top-level HDL design.

### What the HDL Scripts Do

In `vsplit/`, we provide **n+5** Python scripts (where **n** is the number of submodules). Together, they:

1. Establish a **unified streaming interface** and per-module interface specifications.
2. Generate textual **functional and interface specs** (`specX.md`) from C/C++ submodules.
3. Prepare per-module simulation environments (copying and adapting `sim.py` and `compileh.py`).
4. Drive **per-module Verilog generation and syntax repair** using the LLM and a retrieval-augmented rule library.
5. Run **differential verification** for each submodule against HLS-generated golden HDL, iteratively repairing functional mismatches.
6. Finally, **concatenate all verified submodules** into a top-level Verilog design and run top-level verification.

### Directory Structure of `vsplit/`

```text
/vsplit/
  config.py                 # Path and LLM configuration
  llm_utils.py              # LLM invocation, logging, code extraction utilities
  cpp_utils.py              # C/C++ prototype parsing and bit-width mapping
  s1_interface_setup.py     # Count modules, create aesvX dirs, generate interface .sv/.md, prepare n s4_aesX.py scripts
  s2_generate_specs.py      # Generate specX.md for each submodule
  s3_prepare_sim.py         # Copy and edit sim.py and compileh.py for each aesvX
  s5_concat_and_test.py     # Concatenate aes1..aesn into aes_concat.v and test_concat.v; run system-level test
  run_all.py                # Top-level orchestrator; can run a single stage or a single submodule

  logs/                     # LLM prompt/response logs (created at runtime)
```

Each `aesvX/` contains the HDL, testbench, and simulation scripts for that submodule.

### Inputs

Before running `vsplit/`, make sure you have:

- For each submodule `aes{id}` (from Part I):
  - `aes{id}.h`
  - `aes{id}.cpp`
  - `test{id}.cpp` (or an equivalent testbench)

- From the C decomposition results:
  - A machine-readable description of modules and interfaces (e.g., the Round 1 JSON or similar metadata).

- (Optional) Full C++ top-level design:
  - `aes_concat.cpp`
  - `test_concat.cpp`

You also need a working `compileh.py` that can synthesize C/C++ with HLS and compile/simulate HDL with your RTL simulator.

### Usage for `vsplit`

From inside the **`vsplit/`** directory:

1. **Configure Paths and LLM**

   - Edit `config.py` to set:
     - Paths to C/C++ submodules and testbenches.
     - Paths to HLS and RTL tools.
     - LLM model name and parameters.
   - Ensure `OPENAI_API_KEY` is set.

2. **Run the Full Workflow**

   ```bash
   cd vsplit/

   # Run the full modular flow (all stages and rounds)
   python run_all.py
   ```

3. **Run Specific Stages Only**

   ```bash
   # Run only a single stage S1/S2/S3/S5
   python run_all.py --only-s 1
   python run_all.py --only-s 2
   python run_all.py --only-s 3
   python run_all.py --only-s 5
   ```

4. **Run Specific Submodule Rounds**

   ```bash
   # Run only round K (Verilog generation and simulation for submodule K)
   python run_all.py --round K

   # Run a range of rounds (for example, K = 2 through 4)
   python run_all.py --start-round 2 --end-round 4
   ```

### Outputs

After running Part II, you should obtain:

- **Per-submodule outputs** (for each `aesvX/`):
  - `aesvX/specX.md` – functional and interface specification used as the LLM prompt.
  - `aesvX/aesX.v` – LLM-generated Verilog module (after syntax and functional repair).
  - `aesvX/testX.v` – HDL testbench for the submodule.
  - `aesvX/sim.py` – simulation script for your RTL simulator.
  - `aesvX/report` – verification report (including differential comparison results).

- **Top-level outputs:**
  - `/aes_concat/aes_concat.v` – concatenated top-level HDL composed from all verified submodules.
  - `/aes_concat/test_concat.v` – top-level HDL testbench.
  - `/aes_concat/concat_check` – system-level verification log (pass/fail, mismatched cases).

- **Logs:**
  - `/vsplit/logs/` – all LLM prompts and responses, useful for debugging and audit.

> All LLM prompts and outputs are saved under `/vsplit/logs/` for reproducibility.

---

## End-to-End Usage

A typical end-to-end use of this repository looks like:

1. **Prepare Inputs**
   - Original C/C++ design and testbench (e.g., `aes.cpp`, `aes.h`, `test.cpp`, etc.).
   - A functioning `compileh.py` that can:
     - Run HLS synthesis (C/C++ → HDL).
     - Run RTL simulation (both HLS-generated HDL and LLM-generated HDL).

2. **Run Part I – C Decomposition & Re-integration**
   - Change to the decomposition directory (where `run_pipeline.py` is located).
   - Run:

     ```bash
     python3 run_pipeline.py
     ```

   - Confirm that:
     - All submodules compile and pass their tests.
     - The concatenated top-level C function `aes_concat_top(...)` passes the top-level testbench and matches the original design behavior.

3. **Run Part II – HDL Submodule Generation & Verification**
   - Change to the HDL directory `vsplit/`.
   - Edit `config.py` to point to:
     - Submodule C/C++ sources.
     - HLS tool and RTL simulator.
   - Run:

     ```bash
     python run_all.py
     ```

   - The pipeline will:
     - Generate HDL for each submodule.
     - Automatically repair syntax issues using compiler/simulator feedback plus a retrieval-augmented rule library.
     - Perform differential verification against HLS-generated HDL and repair functional mismatches.
     - Concatenate submodules into a top-level HDL and run system-level checks.

4. **Analyze Results**
   - Inspect `aesvX/report.txt` for per-module results.
   - Inspect `/aes_concat/concat_check.txt` for top-level correctness.
   - Use `/vsplit/logs/` to trace how the LLM fixed syntax/functional issues.

At the end of this process, you obtain a **functionally correct LLM-generated HDL design** that is validated against the HLS reference and is suitable for downstream implementation and PPA evaluation.

---

## Citation

If you use this repository or build on its ideas in your research, please cite:

> **CorrectHDL: Agentic HDL Design with LLMs Leveraging High-Level Synthesis as Reference**

Thank you very much for your attention.
