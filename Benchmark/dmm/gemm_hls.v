// ----------------------------------------------------------------------
//  HLS HDL:        Verilog Netlister
//  HLS Version:    2022.2/1008433 Production Release
//  HLS Date:       Fri Aug 19 18:40:59 PDT 2022
// 
//  Generated by:   
//  
// ----------------------------------------------------------------------

// 
// ------------------------------------------------------------------
//  Design Unit:    gemm_ram_nangate_45nm_separate_beh_RAM_separateRW_wport_3_256_21_8_0_1_0_0_0_1_1_21_256_1_1_gen
// ------------------------------------------------------------------


module gemm_ram_nangate_45nm_separate_beh_RAM_separateRW_wport_3_256_21_8_0_1_0_0_0_1_1_21_256_1_1_gen
    (
  we, addr_wr, data_in, data_in_d, addr_wr_d, we_d
);
  output we;
  output [7:0] addr_wr;
  output [20:0] data_in;
  input [20:0] data_in_d;
  input [7:0] addr_wr_d;
  input we_d;



  // Interconnect Declarations for Component Instantiations 
  assign we = (we_d);
  assign addr_wr = (addr_wr_d);
  assign data_in = (data_in_d);
endmodule

// ------------------------------------------------------------------
//  Design Unit:    gemm_ram_nangate_45nm_separate_beh_RAM_separateRW_rport_2_256_21_8_0_1_0_0_0_1_1_21_256_1_1_gen
// ------------------------------------------------------------------


module gemm_ram_nangate_45nm_separate_beh_RAM_separateRW_rport_2_256_21_8_0_1_0_0_0_1_1_21_256_1_1_gen
    (
  data_out, re, addr_rd, addr_rd_d, re_d, data_out_d
);
  input [20:0] data_out;
  output re;
  output [7:0] addr_rd;
  input [7:0] addr_rd_d;
  input re_d;
  output [20:0] data_out_d;



  // Interconnect Declarations for Component Instantiations 
  assign data_out_d = data_out;
  assign re = (re_d);
  assign addr_rd = (addr_rd_d);
endmodule

// ------------------------------------------------------------------
//  Design Unit:    gemm_ram_nangate_45nm_separate_beh_RAM_separateRW_rport_1_256_21_8_0_1_0_0_0_1_1_21_256_1_1_gen
// ------------------------------------------------------------------


module gemm_ram_nangate_45nm_separate_beh_RAM_separateRW_rport_1_256_21_8_0_1_0_0_0_1_1_21_256_1_1_gen
    (
  data_out, re, addr_rd, addr_rd_d, re_d, data_out_d
);
  input [20:0] data_out;
  output re;
  output [7:0] addr_rd;
  input [7:0] addr_rd_d;
  input re_d;
  output [20:0] data_out_d;



  // Interconnect Declarations for Component Instantiations 
  assign data_out_d = data_out;
  assign re = (re_d);
  assign addr_rd = (addr_rd_d);
endmodule

// ------------------------------------------------------------------
//  Design Unit:    gemm_core_core_fsm
//  FSM Module
// ------------------------------------------------------------------


module gemm_core_core_fsm (
  clk, rst, fsm_output, DOT_LOOP_C_0_tr0, COL_LOOP_C_0_tr0, ROW_LOOP_C_0_tr0
);
  input clk;
  input rst;
  output [5:0] fsm_output;
  reg [5:0] fsm_output;
  input DOT_LOOP_C_0_tr0;
  input COL_LOOP_C_0_tr0;
  input ROW_LOOP_C_0_tr0;


  // FSM State Type Declaration for gemm_core_core_fsm_1
  parameter
    core_rlp_C_0 = 3'd0,
    main_C_0 = 3'd1,
    DOT_LOOP_C_0 = 3'd2,
    COL_LOOP_C_0 = 3'd3,
    ROW_LOOP_C_0 = 3'd4,
    main_C_1 = 3'd5;

  reg [2:0] state_var;
  reg [2:0] state_var_NS;


  // Interconnect Declarations for Component Instantiations 
  always @(*)
  begin : gemm_core_core_fsm_1
    case (state_var)
      main_C_0 : begin
        fsm_output = 6'b000010;
        state_var_NS = DOT_LOOP_C_0;
      end
      DOT_LOOP_C_0 : begin
        fsm_output = 6'b000100;
        if ( DOT_LOOP_C_0_tr0 ) begin
          state_var_NS = COL_LOOP_C_0;
        end
        else begin
          state_var_NS = DOT_LOOP_C_0;
        end
      end
      COL_LOOP_C_0 : begin
        fsm_output = 6'b001000;
        if ( COL_LOOP_C_0_tr0 ) begin
          state_var_NS = ROW_LOOP_C_0;
        end
        else begin
          state_var_NS = DOT_LOOP_C_0;
        end
      end
      ROW_LOOP_C_0 : begin
        fsm_output = 6'b010000;
        if ( ROW_LOOP_C_0_tr0 ) begin
          state_var_NS = main_C_1;
        end
        else begin
          state_var_NS = DOT_LOOP_C_0;
        end
      end
      main_C_1 : begin
        fsm_output = 6'b100000;
        state_var_NS = main_C_0;
      end
      // core_rlp_C_0
      default : begin
        fsm_output = 6'b000001;
        state_var_NS = main_C_0;
      end
    endcase
  end

  always @(posedge clk) begin
    if ( rst ) begin
      state_var <= core_rlp_C_0;
    end
    else begin
      state_var <= state_var_NS;
    end
  end

endmodule

// ------------------------------------------------------------------
//  Design Unit:    gemm_core
// ------------------------------------------------------------------


module gemm_core (
  clk, rst, m1_triosy_lz, m2_triosy_lz, prod_triosy_lz, m1_rsci_addr_rd_d, m1_rsci_data_out_d,
      m2_rsci_addr_rd_d, m2_rsci_data_out_d, prod_rsci_data_in_d, prod_rsci_addr_wr_d,
      prod_rsci_we_d, m1_rsci_re_d_pff
);
  input clk;
  input rst;
  output m1_triosy_lz;
  output m2_triosy_lz;
  output prod_triosy_lz;
  output [7:0] m1_rsci_addr_rd_d;
  input [20:0] m1_rsci_data_out_d;
  output [7:0] m2_rsci_addr_rd_d;
  input [20:0] m2_rsci_data_out_d;
  output [20:0] prod_rsci_data_in_d;
  output [7:0] prod_rsci_addr_wr_d;
  output prod_rsci_we_d;
  output m1_rsci_re_d_pff;


  // Interconnect Declarations
  wire [5:0] fsm_output;
  reg COL_LOOP_sum_31_sva;
  reg [29:0] COL_LOOP_sum_30_1_sva;
  reg COL_LOOP_sum_0_sva;
  wire [32:0] DOT_LOOP_acc_sat_sva_1;
  wire [33:0] nl_DOT_LOOP_acc_sat_sva_1;
  reg reg_prod_triosy_obj_ld_cse;
  wire ROW_LOOP_i_or_cse;
  reg [3:0] ROW_LOOP_i_4_0_sva_3_0_2;
  reg [3:0] COL_LOOP_j_4_0_sva_3_0_2;
  wire [29:0] COL_LOOP_sum_30_1_sva_2;
  wire COL_LOOP_sum_0_sva_4;
  wire [3:0] DOT_LOOP_k_4_0_sva_3_0_mx0;
  wire [4:0] z_out;
  wire [5:0] nl_z_out;
  reg [3:0] DOT_LOOP_k_4_0_sva_3_0_2;
  wire DOT_LOOP_nor_ovfl_sva_1;
  wire DOT_LOOP_and_unfl_sva_1;
  wire COL_LOOP_j_or_cse;

  wire ROW_LOOP_i_not_nl;
  wire not_nl;
  wire not_14_nl;
  wire[29:0] DOT_LOOP_nor_1_nl;
  wire[13:0] DOT_LOOP_term_mul_nl;
  wire signed [27:0] nl_DOT_LOOP_term_mul_nl;
  wire[3:0] ROW_LOOP_i_ROW_LOOP_i_and_nl;
  wire[3:0] ROW_LOOP_i_mux_nl;
  wire nor_1_nl;
  wire[3:0] COL_LOOP_j_COL_LOOP_j_and_nl;
  wire[3:0] COL_LOOP_j_mux_nl;
  wire ROW_LOOP_i_not_2_nl;
  wire[3:0] DOT_LOOP_mux1h_1_nl;

  // Interconnect Declarations for Component Instantiations 
  wire  nl_gemm_core_core_fsm_inst_DOT_LOOP_C_0_tr0;
  assign nl_gemm_core_core_fsm_inst_DOT_LOOP_C_0_tr0 = z_out[4];
  wire  nl_gemm_core_core_fsm_inst_COL_LOOP_C_0_tr0;
  assign nl_gemm_core_core_fsm_inst_COL_LOOP_C_0_tr0 = z_out[4];
  wire  nl_gemm_core_core_fsm_inst_ROW_LOOP_C_0_tr0;
  assign nl_gemm_core_core_fsm_inst_ROW_LOOP_C_0_tr0 = z_out[4];
  mgc_io_sync_v2 #(.valid(32'sd0)) m1_triosy_obj (
      .ld(reg_prod_triosy_obj_ld_cse),
      .lz(m1_triosy_lz)
    );
  mgc_io_sync_v2 #(.valid(32'sd0)) m2_triosy_obj (
      .ld(reg_prod_triosy_obj_ld_cse),
      .lz(m2_triosy_lz)
    );
  mgc_io_sync_v2 #(.valid(32'sd0)) prod_triosy_obj (
      .ld(reg_prod_triosy_obj_ld_cse),
      .lz(prod_triosy_lz)
    );
  gemm_core_core_fsm gemm_core_core_fsm_inst (
      .clk(clk),
      .rst(rst),
      .fsm_output(fsm_output),
      .DOT_LOOP_C_0_tr0(nl_gemm_core_core_fsm_inst_DOT_LOOP_C_0_tr0),
      .COL_LOOP_C_0_tr0(nl_gemm_core_core_fsm_inst_COL_LOOP_C_0_tr0),
      .ROW_LOOP_C_0_tr0(nl_gemm_core_core_fsm_inst_ROW_LOOP_C_0_tr0)
    );
  assign ROW_LOOP_i_or_cse = (fsm_output[1]) | (fsm_output[4]);
  assign COL_LOOP_j_or_cse = (fsm_output[3]) | ROW_LOOP_i_or_cse;
  assign COL_LOOP_sum_0_sva_4 = ~((~((DOT_LOOP_acc_sat_sva_1[0]) | DOT_LOOP_nor_ovfl_sva_1))
      | DOT_LOOP_and_unfl_sva_1);
  assign not_14_nl = ~ COL_LOOP_j_or_cse;
  assign DOT_LOOP_k_4_0_sva_3_0_mx0 = MUX_v_4_2_2(4'b0000, (z_out[3:0]), not_14_nl);
  assign DOT_LOOP_nor_1_nl = ~(MUX_v_30_2_2((DOT_LOOP_acc_sat_sva_1[30:1]), 30'b111111111111111111111111111111,
      DOT_LOOP_nor_ovfl_sva_1));
  assign COL_LOOP_sum_30_1_sva_2 = ~(MUX_v_30_2_2(DOT_LOOP_nor_1_nl, 30'b111111111111111111111111111111,
      DOT_LOOP_and_unfl_sva_1));
  assign nl_DOT_LOOP_term_mul_nl = $signed((m1_rsci_data_out_d[13:0])) * $signed((m2_rsci_data_out_d[13:0]));
  assign DOT_LOOP_term_mul_nl = nl_DOT_LOOP_term_mul_nl[13:0];
  assign nl_DOT_LOOP_acc_sat_sva_1 = conv_s2s_32_33({COL_LOOP_sum_31_sva , COL_LOOP_sum_30_1_sva
      , COL_LOOP_sum_0_sva}) + conv_s2s_14_33(DOT_LOOP_term_mul_nl);
  assign DOT_LOOP_acc_sat_sva_1 = nl_DOT_LOOP_acc_sat_sva_1[32:0];
  assign DOT_LOOP_nor_ovfl_sva_1 = ~((DOT_LOOP_acc_sat_sva_1[32:31]!=2'b01));
  assign DOT_LOOP_and_unfl_sva_1 = (DOT_LOOP_acc_sat_sva_1[32:31]==2'b10);
  assign ROW_LOOP_i_mux_nl = MUX_v_4_2_2(ROW_LOOP_i_4_0_sva_3_0_2, (z_out[3:0]),
      fsm_output[4]);
  assign nor_1_nl = ~((fsm_output[5]) | (fsm_output[0]) | (fsm_output[1]));
  assign ROW_LOOP_i_ROW_LOOP_i_and_nl = MUX_v_4_2_2(4'b0000, ROW_LOOP_i_mux_nl, nor_1_nl);
  assign m1_rsci_addr_rd_d = {ROW_LOOP_i_ROW_LOOP_i_and_nl , DOT_LOOP_k_4_0_sva_3_0_mx0};
  assign m1_rsci_re_d_pff = ~(((~ (z_out[4])) & (fsm_output[3])) | (fsm_output[1])
      | ((~ (z_out[4])) & (fsm_output[2])) | ((~ (z_out[4])) & (fsm_output[4])));
  assign COL_LOOP_j_mux_nl = MUX_v_4_2_2(COL_LOOP_j_4_0_sva_3_0_2, (z_out[3:0]),
      fsm_output[3]);
  assign ROW_LOOP_i_not_2_nl = ~ ROW_LOOP_i_or_cse;
  assign COL_LOOP_j_COL_LOOP_j_and_nl = MUX_v_4_2_2(4'b0000, COL_LOOP_j_mux_nl, ROW_LOOP_i_not_2_nl);
  assign m2_rsci_addr_rd_d = {DOT_LOOP_k_4_0_sva_3_0_mx0 , COL_LOOP_j_COL_LOOP_j_and_nl};
  assign prod_rsci_data_in_d = {(COL_LOOP_sum_30_1_sva_2[19:0]) , COL_LOOP_sum_0_sva_4};
  assign prod_rsci_addr_wr_d = {ROW_LOOP_i_4_0_sva_3_0_2 , COL_LOOP_j_4_0_sva_3_0_2};
  assign prod_rsci_we_d = ~((z_out[4]) & (fsm_output[2]));
  always @(posedge clk) begin
    if ( rst ) begin
      reg_prod_triosy_obj_ld_cse <= 1'b0;
      DOT_LOOP_k_4_0_sva_3_0_2 <= 4'b0000;
      COL_LOOP_sum_31_sva <= 1'b0;
      COL_LOOP_sum_30_1_sva <= 30'b000000000000000000000000000000;
      COL_LOOP_sum_0_sva <= 1'b0;
    end
    else begin
      reg_prod_triosy_obj_ld_cse <= (z_out[4]) & (fsm_output[4]);
      DOT_LOOP_k_4_0_sva_3_0_2 <= DOT_LOOP_k_4_0_sva_3_0_mx0;
      COL_LOOP_sum_31_sva <= ~((~((DOT_LOOP_acc_sat_sva_1[31]) | DOT_LOOP_and_unfl_sva_1))
          | DOT_LOOP_nor_ovfl_sva_1 | COL_LOOP_j_or_cse);
      COL_LOOP_sum_30_1_sva <= MUX_v_30_2_2(30'b000000000000000000000000000000, COL_LOOP_sum_30_1_sva_2,
          not_nl);
      COL_LOOP_sum_0_sva <= COL_LOOP_sum_0_sva_4 & (~ COL_LOOP_j_or_cse);
    end
  end
  always @(posedge clk) begin
    if ( rst ) begin
      ROW_LOOP_i_4_0_sva_3_0_2 <= 4'b0000;
    end
    else if ( ROW_LOOP_i_or_cse ) begin
      ROW_LOOP_i_4_0_sva_3_0_2 <= MUX_v_4_2_2(4'b0000, (z_out[3:0]), (fsm_output[4]));
    end
  end
  always @(posedge clk) begin
    if ( rst ) begin
      COL_LOOP_j_4_0_sva_3_0_2 <= 4'b0000;
    end
    else if ( COL_LOOP_j_or_cse ) begin
      COL_LOOP_j_4_0_sva_3_0_2 <= MUX_v_4_2_2(4'b0000, (z_out[3:0]), ROW_LOOP_i_not_nl);
    end
  end
  assign not_nl = ~ COL_LOOP_j_or_cse;
  assign ROW_LOOP_i_not_nl = ~ ROW_LOOP_i_or_cse;
  assign DOT_LOOP_mux1h_1_nl = MUX1HOT_v_4_3_2(DOT_LOOP_k_4_0_sva_3_0_2, COL_LOOP_j_4_0_sva_3_0_2,
      ROW_LOOP_i_4_0_sva_3_0_2, {(fsm_output[2]) , (fsm_output[3]) , (fsm_output[4])});
  assign nl_z_out = conv_u2u_4_5(DOT_LOOP_mux1h_1_nl) + 5'b00001;
  assign z_out = nl_z_out[4:0];

  function automatic [3:0] MUX1HOT_v_4_3_2;
    input [3:0] input_2;
    input [3:0] input_1;
    input [3:0] input_0;
    input [2:0] sel;
    reg [3:0] result;
  begin
    result = input_0 & {4{sel[0]}};
    result = result | (input_1 & {4{sel[1]}});
    result = result | (input_2 & {4{sel[2]}});
    MUX1HOT_v_4_3_2 = result;
  end
  endfunction


  function automatic [29:0] MUX_v_30_2_2;
    input [29:0] input_0;
    input [29:0] input_1;
    input  sel;
    reg [29:0] result;
  begin
    case (sel)
      1'b0 : begin
        result = input_0;
      end
      default : begin
        result = input_1;
      end
    endcase
    MUX_v_30_2_2 = result;
  end
  endfunction


  function automatic [3:0] MUX_v_4_2_2;
    input [3:0] input_0;
    input [3:0] input_1;
    input  sel;
    reg [3:0] result;
  begin
    case (sel)
      1'b0 : begin
        result = input_0;
      end
      default : begin
        result = input_1;
      end
    endcase
    MUX_v_4_2_2 = result;
  end
  endfunction


  function automatic [32:0] conv_s2s_14_33 ;
    input [13:0]  vector ;
  begin
    conv_s2s_14_33 = {{19{vector[13]}}, vector};
  end
  endfunction


  function automatic [32:0] conv_s2s_32_33 ;
    input [31:0]  vector ;
  begin
    conv_s2s_32_33 = {vector[31], vector};
  end
  endfunction


  function automatic [4:0] conv_u2u_4_5 ;
    input [3:0]  vector ;
  begin
    conv_u2u_4_5 = {1'b0, vector};
  end
  endfunction

endmodule

// ------------------------------------------------------------------
//  Design Unit:    gemm
// ------------------------------------------------------------------


module gemm (
  clk, rst, m1_rsc_addr_rd, m1_rsc_re, m1_rsc_data_out, m1_triosy_lz, m2_rsc_addr_rd,
      m2_rsc_re, m2_rsc_data_out, m2_triosy_lz, prod_rsc_data_in, prod_rsc_addr_wr,
      prod_rsc_we, prod_triosy_lz
);
  input clk;
  input rst;
  output [7:0] m1_rsc_addr_rd;
  output m1_rsc_re;
  input [20:0] m1_rsc_data_out;
  output m1_triosy_lz;
  output [7:0] m2_rsc_addr_rd;
  output m2_rsc_re;
  input [20:0] m2_rsc_data_out;
  output m2_triosy_lz;
  output [20:0] prod_rsc_data_in;
  output [7:0] prod_rsc_addr_wr;
  output prod_rsc_we;
  output prod_triosy_lz;


  // Interconnect Declarations
  wire [7:0] m1_rsci_addr_rd_d;
  wire [20:0] m1_rsci_data_out_d;
  wire [7:0] m2_rsci_addr_rd_d;
  wire [20:0] m2_rsci_data_out_d;
  wire [20:0] prod_rsci_data_in_d;
  wire [7:0] prod_rsci_addr_wr_d;
  wire prod_rsci_we_d;
  wire m1_rsci_re_d_iff;


  // Interconnect Declarations for Component Instantiations 
  gemm_ram_nangate_45nm_separate_beh_RAM_separateRW_rport_1_256_21_8_0_1_0_0_0_1_1_21_256_1_1_gen
      m1_rsci (
      .data_out(m1_rsc_data_out),
      .re(m1_rsc_re),
      .addr_rd(m1_rsc_addr_rd),
      .addr_rd_d(m1_rsci_addr_rd_d),
      .re_d(m1_rsci_re_d_iff),
      .data_out_d(m1_rsci_data_out_d)
    );
  gemm_ram_nangate_45nm_separate_beh_RAM_separateRW_rport_2_256_21_8_0_1_0_0_0_1_1_21_256_1_1_gen
      m2_rsci (
      .data_out(m2_rsc_data_out),
      .re(m2_rsc_re),
      .addr_rd(m2_rsc_addr_rd),
      .addr_rd_d(m2_rsci_addr_rd_d),
      .re_d(m1_rsci_re_d_iff),
      .data_out_d(m2_rsci_data_out_d)
    );
  gemm_ram_nangate_45nm_separate_beh_RAM_separateRW_wport_3_256_21_8_0_1_0_0_0_1_1_21_256_1_1_gen
      prod_rsci (
      .we(prod_rsc_we),
      .addr_wr(prod_rsc_addr_wr),
      .data_in(prod_rsc_data_in),
      .data_in_d(prod_rsci_data_in_d),
      .addr_wr_d(prod_rsci_addr_wr_d),
      .we_d(prod_rsci_we_d)
    );
  gemm_core gemm_core_inst (
      .clk(clk),
      .rst(rst),
      .m1_triosy_lz(m1_triosy_lz),
      .m2_triosy_lz(m2_triosy_lz),
      .prod_triosy_lz(prod_triosy_lz),
      .m1_rsci_addr_rd_d(m1_rsci_addr_rd_d),
      .m1_rsci_data_out_d(m1_rsci_data_out_d),
      .m2_rsci_addr_rd_d(m2_rsci_addr_rd_d),
      .m2_rsci_data_out_d(m2_rsci_data_out_d),
      .prod_rsci_data_in_d(prod_rsci_data_in_d),
      .prod_rsci_addr_wr_d(prod_rsci_addr_wr_d),
      .prod_rsci_we_d(prod_rsci_we_d),
      .m1_rsci_re_d_pff(m1_rsci_re_d_iff)
    );
endmodule



